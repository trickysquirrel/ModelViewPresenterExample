
Stuff evolves at different rates

views   | view logic (presentation) | business logic | app navigation
View&VC | present stuff             | get stuff      | go somewhere


(you could argue about the order of bl and an but these are different for differnent apps and lifecycle of the app)

Need to appreciate that there is no where in the business that actually describes how the app work, there are the stories we used to build the app, but they never contain all the information of the little things that we had to fix along the way.  How often do you see code and have no idea why its there "it looks wrong, but maybe it has a purpose", and your too scared to change it (enter code rot).  The only place that can describe how the app works are the tests.  And if we have all the tests then people naturally refactor stuff and in my experience alot happier.

Things to bear in mind...

1. Write tests that do not care about how the result was produced, we want tests that just check the result.  That way when we need to refactor the inner workings of a class we don't need to change the tests.
2. You can write all the unit tests you like, but if some of those classes you are testing include public variables, you have introduce time, and unit tests are just a snapshot of time, so the tests no longer tell you if something works through the life cycle of the app.  By removing time, your unit test tell you exactly how the object works over the entire lifecycle of the app.
3. If your business logic include a view (fastest changing object type) your going to have to change the business tests more, by disconnecting fast evolving objects from the slower one, less maintance will be needed.  By keeping objects that deal with a similar theme isolated we'll be maintaining the tests less.
4. Isolate multithreading to keep test easier to read.





Split the app into a few distint parts

View&VC | present stuff | get stuff | go somewhere

tests are aranged around each area and only care about inputs and outputs, e.g

get stuff: if I ask for data give me data, don't care too much wether its from db or network, exception being images
present stuff: ask for the initial view state and check the returning view model struct, we don't care how it done.  Maybe its just one object, maybe its Redux, maybe you have view configurations, it does not matter.  Your free to refractor from redux to something else and the tests never change so you know you've not broken anything.  Also this area has no concept of how this information is to be displayed, e.g. maybe its a table, collection or stack view - should not matter
View: are just dumb and just set stuff.
VC: contain trigger points for features, knows how to display the viewmodel struct
go somewhere: an object that takes the users to a different place in the app



When writing code we tend to just, fix bugs or refactor, but 80%-90% of what we do is add/remove/change features.  If we also spend 80% just reading code thats already there so we know how to change it, it makes sense to really show to the read how the feature works.
